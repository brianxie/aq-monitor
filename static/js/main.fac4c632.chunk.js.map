{"version":3,"sources":["Button.js","ResponseUtils.js","Sensor.js","PositionComponent.js","SensorsComponent.js","TimeUtils.js","TimerComponent.js","Status.js","index.js"],"names":["Button","className","type","class","onClick","props","handleClick","React","Component","ResponseStates","ResponseProperties","ResponseSuccess","value","ResponseFailure","err","ResponsePending","TimeDataKeys","REALTIME","TEN_MINUTES","THIRTY_MINUTES","ONE_HOUR","SIX_HOURS","ONE_DAY","LocationKeys","LATITUDE","LONGITUDE","SensorModel","timeData","locationData","this","Object","keys","map","keyEnum","key","toString","reduce","acc","curr","PositionComponent","getPositionString","position","tag","ResponseUtils","parsePositionValue","Error","positionValue","Sensor","SensorsComponent","getSensorsText","sensorModels","model","getSingleSensorElem","sensorModel","C","C_low","C_high","I_low","I_high","computeAQIPM25","TimerState","Timer","timerState","remainingTimeMillis","Math","floor","TimerComponent","state","timer","setState","TimeUtils","pollIntervalMillis","timerId","setInterval","updateTimer","clearInterval","renderTimer","deltaMillis","defaultDuration","newDuration","callback","distanceFromPosition","taggedResult","dLat","lat","dLon","lon","sqrt","pow","constructLocationData","latitude","longitude","getRawResults","fetch","then","response","ok","status","checkResponseOk","json","jsonObj","results","result","jsonResult","parseFloat","Lat","Lon","Status","updateStatus","error","resultErrorString","message","positionErrorString","refreshLocation","positionPromise","console","log","Date","hasPreviousPosition","Promise","resolve","reject","navigator","geolocation","getCurrentPosition","coords","catch","handlePositionError","rawResultsPromise","handleResultError","all","promises","taggedResults","sort","a","b","sortedResults","slice","stats","JSON","parse","Stats","v","v1","v2","v3","v4","v5","Monitor","statusActive","toggleStatus","appearFn","CSSTransition","in","appear","timeout","classNames","renderButton","renderStatusPlaceholder","renderStatus","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.fac4c632.chunk.js","sourcesContent":["import React from 'react';\n\n// handleClick\n// TODO: add the text\nclass Button extends React.Component {\n  render() {\n    return (\n      <button\n        className=\"Button\"\n        type=\"button\"\n        class=\"btn btn-outline-secondary btn-lg\"\n        onClick={() => this.props.handleClick()}\n      >\n        {\"Placeholder text expand/collapse\"}\n      </button>\n    );\n  }\n}\n\nexport default Button;\n","export const ResponseStates = {\n  SUCCESS: \"success\",\n  FAILURE: \"failure\",\n  PENDING: \"pending\",\n}\n\nexport const ResponseProperties = {\n  TAG: \"tag\",\n  VALUE: \"value\",\n  ERR: \"err\",\n}\n\nexport const Response = (response) => ({\n  [ResponseProperties.TAG]: response[ResponseProperties.TAG],\n  [ResponseProperties.VALUE]: response[ResponseProperties.TAG] === ResponseStates.SUCCESS\n    ? response[ResponseProperties.VALUE]\n    : null,\n  [ResponseProperties.ERR]: response[ResponseProperties.TAG] === ResponseStates.FAILURE\n    ? response[ResponseProperties.ERR]\n    : null,\n});\n\n// TODO whoops, you forgot to wrap the actual Response\nexport const ResponseSuccess = (value) => ({\n  [ResponseProperties.TAG]: ResponseStates.SUCCESS,\n  [ResponseProperties.VALUE]: value,\n});\n\nexport const ResponseFailure = (err) => ({\n  [ResponseProperties.TAG]: ResponseStates.FAILURE,\n  [ResponseProperties.ERR]: err,\n});\n\nexport const ResponsePending = () => ({\n  [ResponseProperties.TAG]: ResponseStates.PENDING,\n});\n","// Datatypes for constructing a sensor model.\n// This is an internal, non-rendered data representation.\n// The SensorsComponent React component deals with actually using these fields.\nexport const TimeDataKeys = {\n  REALTIME: \"realtime\",\n  TEN_MINUTES: \"ten_minutes\",\n  THIRTY_MINUTES: \"thirty_minutes\",\n  ONE_HOUR: \"one_hour\",\n  SIX_HOURS: \"six_hours\",\n  ONE_DAY: \"one_day\",\n}\n\nexport const LocationKeys = {\n  LATITUDE: \"latitude\",\n  LONGITUDE: \"longitude\",\n}\n\nexport class SensorModel {\n  constructor(timeData, locationData) {\n    // These could be classes, but having enumerable properties is convenient.\n    this.timeData = timeData;\n    this.locationData = locationData;\n  }\n\n  toString() {\n    var locationString =\n        Object.keys(LocationKeys)\n          .map(keyEnum => LocationKeys[keyEnum])\n          .map(key => key.toString() + \": \" + this.locationData[key].toString())\n          .reduce((acc, curr) => acc + \"\\n\" + curr);\n      \n    var timeDataString =\n        Object.keys(TimeDataKeys)\n          .map(keyEnum => TimeDataKeys[keyEnum])\n          .map(key => key.toString() + \": \" + this.timeData[key].toString())\n          .reduce((acc, curr) => acc + \"\\n\" + curr);\n\n    return locationString + \"\\n\" + timeDataString;\n  }\n}\n","import React from 'react';\nimport * as ResponseUtils from './ResponseUtils';\nimport * as Sensor from './Sensor';\n\n// props::position\nclass PositionComponent extends React.Component {\n  render() {\n    return (\n      <div\n        className=\"PositionComponent\"\n        class=\"card-body\"\n      >\n        {this.getPositionString()}\n      </div>\n    );\n  }\n\n  getPositionString() {\n    var position = this.props.position;\n    if (position == null) {\n      return \"Position unknown\";\n    }\n    var tag = position[ResponseUtils.ResponseProperties.TAG];\n    switch (tag) {\n      case ResponseUtils.ResponseStates.SUCCESS:\n        return \"Postion: \" +\n          this.parsePositionValue(\n            position[ResponseUtils.ResponseProperties.VALUE]);\n      case ResponseUtils.ResponseStates.FAILURE:\n        return \"Error: \" + position[ResponseUtils.ResponseProperties.ERR];\n      case ResponseUtils.ResponseStates.PENDING:\n        return \"Fetching position...\";\n      default:\n        throw new Error(\"Unrecognized tag: \" + tag.toString());\n    }\n  }\n\n  parsePositionValue(positionValue) {\n    return \"Latitude: \" + positionValue[Sensor.LocationKeys.LATITUDE].toString()\n      + \" \"\n      + \"Longitude: \" + positionValue[Sensor.LocationKeys.LONGITUDE].toString();\n  }\n}\n\nexport default PositionComponent;\n","import React from 'react';\nimport * as ResponseUtils from './ResponseUtils';\nimport * as Sensor from './Sensor';\n\n// haha\nfunction computeAQIPM25(C) {\n  var C_low;\n  var C_high;\n  var I_low;\n  var I_high;\n\n  if (C <= 12.0) {\n    C_low = 0.0;\n    C_high = 12.0;\n    I_low = 0;\n    I_high = 50;\n  } else if (C <= 35.4) {\n    C_low = 12.1;\n    C_high = 35.4;\n    I_low = 51;\n    I_high = 100;\n  } else if (C <= 55.4) {\n    C_low = 35.5;\n    C_high = 55.4;\n    I_low = 101;\n    I_high = 150;\n  } else if (C <= 150.4) {\n    C_low = 55.5;\n    C_high = 150.4;\n    I_low = 151;\n    I_high = 200;\n  } else if (C <= 250.4) {\n    C_low = 150.5;\n    C_high = 250.4;\n    I_low = 201;\n    I_high = 300;\n  } else if (C <= 350.4) {\n    C_low = 250.5;\n    C_high = 350.4;\n    I_low = 301;\n    I_high = 400;\n  } else if (C <= 500.4) {\n    C_low = 350.5;\n    C_high = 500.4;\n    I_low = 401;\n    I_high = 500;\n  } else {\n    throw new Error(\n      \"AQI is _literally incapable_ of measuring such a large concentration\");\n  }\n\n  return ((C - C_low) * (I_high - I_low) / (C_high - C_low)) + I_low;\n}\n\n// props::sensorModels\n// aqi, raw pm, drilldowns. maybe maps?\nclass SensorsComponent extends React.Component {\n  render() {\n    return (\n      <div class=\"card-body\">\n        {this.getSensorsText()}\n      </div>\n    );\n  }\n\n  getSensorsText() {\n    var sensorModels = this.props.sensorModels;\n    if (sensorModels == null) {\n      return \"No sensor data\";\n    }\n    var tag = sensorModels[ResponseUtils.ResponseProperties.TAG];\n    switch (tag) {\n      // TODO: this is gnarly\n      case ResponseUtils.ResponseStates.SUCCESS:\n        var parsedSensors = sensorModels[ResponseUtils.ResponseProperties.VALUE]\n          .map(model => this.getSingleSensorElem(model));\n        return parsedSensors;\n      case ResponseUtils.ResponseStates.FAILURE:\n        return \"Error: \" + sensorModels[ResponseUtils.ResponseProperties.ERR];\n      case ResponseUtils.ResponseStates.PENDING:\n        return \"Fetching sensor data...\";\n      default:\n        throw new Error(\"Unrecognized tag: \" + tag.toString());\n    }\n  }\n\n  // Can obtain more from SensorModel::toString\n  getSingleSensorElem(sensorModel) {\n    return (\n      <div class=\"card-body\">\n        {computeAQIPM25(sensorModel.timeData[Sensor.TimeDataKeys.REALTIME])}\n      </div>\n    );\n  }\n}\n\nexport default SensorsComponent;\n","export const TimerState = {\n  RUNNING: \"running\",\n  PAUSED: \"paused\",\n  EXPIRED: \"expired\",\n  INACTIVE: \"inactive\",\n}\n\nexport class Timer {\n  constructor(timerState, remainingTimeMillis) {\n    this.timerState = timerState;\n    this.remainingTimeMillis = remainingTimeMillis;\n  }\n\n  toString() {\n    return \"Timer state: \" + this.timerState + \"\\n\"\n      + \"Time remaining (seconds): \"\n      + Math.floor(this.remainingTimeMillis / 1000);\n  }\n}\n","import React from 'react';\nimport * as TimeUtils from './TimeUtils';\n\n// props::callback\n// props::pollIntervalMillis\nclass TimerComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      timer: null,\n    };\n  }\n\n  componentDidMount() {\n    const tickIntervalMillis = 1000;\n\n    // Start a timer.\n    this.setState({timer: new TimeUtils.Timer(\n      TimeUtils.TimerState.RUNNING,\n      this.props.pollIntervalMillis)}\n    );\n\n    // Every second, decrement by a second and handle side-effects.\n    this.timerId = setInterval(\n      () => this.updateTimer(\n        tickIntervalMillis,\n        this.props.pollIntervalMillis),\n      tickIntervalMillis\n    );\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timerId);\n  }\n\n  render() {\n    return (\n      <div\n        className=\"TimerComponent\"\n        class=\"card-body\"\n      >\n        {this.renderTimer()}\n      </div>\n    );\n  }\n\n  // TODO: pause, etc\n  updateTimer(deltaMillis, defaultDuration) {\n    var newDuration = this.state.timer.remainingTimeMillis - deltaMillis;\n    var timerState = newDuration <= 0\n      ? TimeUtils.TimerState.EXPIRED\n      : this.state.timer.timerState;\n    this.setState({timer: new TimeUtils.Timer(timerState, newDuration)});\n    // If the timer is already expired, execute the callback and reset the\n    // timer.\n    if (timerState === TimeUtils.TimerState.EXPIRED) {\n      this.props.callback();\n      this.setState({\n        timer: new TimeUtils.Timer(\n          TimeUtils.TimerState.RUNNING, defaultDuration)\n      });\n    }\n  }\n\n  renderTimer() {\n    var timer = this.state.timer;\n    if (timer == null) {\n      return \"No timer present\";\n    }\n    return timer.toString();\n  }\n}\n\nexport default TimerComponent;\n","import React from 'react';\nimport PositionComponent from './PositionComponent';\nimport SensorsComponent from './SensorsComponent';\nimport TimerComponent from './TimerComponent';\nimport * as Sensor from './Sensor';\nimport * as ResponseUtils from './ResponseUtils';\n\n//\n// Helper methods\n//\n\n// Transforms a result into an object containing the latitude, longitude, and\n// result itself.\nfunction createTaggedResult(jsonResult) {\n  return {\n    lat: parseFloat(jsonResult.Lat),\n    lon: parseFloat(jsonResult.Lon),\n    result: jsonResult\n  };\n}\n\n// Computes distance between a single result and the provided position using\n// the Euclidean metric.\nfunction distanceFromPosition(taggedResult, position) {\n  var dLat = taggedResult.lat - position[Sensor.LocationKeys.LATITUDE];\n  var dLon = taggedResult.lon - position[Sensor.LocationKeys.LONGITUDE];\n  return Math.sqrt(Math.pow(dLat, 2) + Math.pow(dLon, 2));\n}\n\n// Sorts results by distance from position, increasing.\nfunction getSortedResults(taggedResults, position) {\n  return taggedResults.sort((a, b) =>\n    distanceFromPosition(a, position) - distanceFromPosition(b, position))\n    .map(taggedResult => taggedResult.result);\n}\n\nfunction constructLocationData(latitude, longitude) {\n  return {\n      [Sensor.LocationKeys.LATITUDE]: latitude,\n      [Sensor.LocationKeys.LONGITUDE]: longitude,\n    };\n}\n\n// Transforms an array of results into an array of SensorModels.\nfunction constructSensorModels(results) {\n  return results.map(result => {\n    var stats = JSON.parse(result.Stats);\n\n    var timeData = {\n      [Sensor.TimeDataKeys.REALTIME]: stats.v,\n      [Sensor.TimeDataKeys.TEN_MINUTES]: stats.v1,\n      [Sensor.TimeDataKeys.THIRTY_MINUTES]: stats.v2,\n      [Sensor.TimeDataKeys.ONE_HOUR]: stats.v3,\n      [Sensor.TimeDataKeys.SIX_HOURS]: stats.v4,\n      [Sensor.TimeDataKeys.ONE_DAY]: stats.v5,\n    };\n    var locationData = constructLocationData(\n      parseFloat(result.Lat), parseFloat(result.Lon));\n\n    return new Sensor.SensorModel(timeData, locationData);\n  });\n}\n\n// Throws an error on a failed response, otherwise returns the response.\nfunction checkResponseOk(response) {\n  if (!response.ok) {\n    throw new Error(response.status);\n  }\n  return response;\n}\n\n// Reads raw sensor results from PurpleAir.\n// Future function.\nfunction getRawResults() {\n  const srcUrl = \"https://www.purpleair.com/json\";\n  return fetch(srcUrl)\n    .then(response => checkResponseOk(response))\n    .then(response => response.json())\n    .then(jsonObj => jsonObj.results)\n    .then(results => results.map(result => createTaggedResult(result)));\n}\n\n// Maximum number of sensors from which to consider data.\nconst MAX_SENSORS = 5;\n\n//\n// React component\n//\n\nclass Status extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      sensorModels: null,\n      position: null,\n      timer: null,\n    };\n  }\n\n  render() {\n    return (\n      <div\n        className=\"Status\"\n        class=\"card text-left border-secondary\"\n      >\n\n        <div\n          className=\"Catchall\"\n          class=\"card-body\"\n        >\n          {\"TODO: catchall text\"}\n        </div>\n\n        <div\n          className=\"Sensors\"\n          class=\"card-body\"\n        >\n          {<SensorsComponent sensorModels={this.state.sensorModels}/>}\n        </div>\n\n        <div\n          className=\"Position\"\n          class=\"card-body\"\n        >\n          {<PositionComponent position={this.state.position} />}\n        </div>\n\n        <div\n          className=\"TimerSection\"\n          class=\"card-body\"\n        >\n          {<TimerComponent\n            pollIntervalMillis={this.props.pollIntervalMillis}\n            callback={() => this.updateStatus(false)} />}\n        </div>\n\n      </div>\n    );\n  }\n\n  // Initial update on render update on render.\n  componentDidMount() {\n    this.updateStatus(true);\n  }\n\n  componentWillUnmount() {\n  }\n\n  // Handles errors in sensor fetching.\n  handleResultError(error) {\n    const resultErrorString = \"Error in fetching sensors: \" + error.message;\n    this.setState({sensorModels: ResponseUtils.ResponseFailure(resultErrorString)});\n    // Rethrow the error for subsequent nodes.\n    throw new Error(resultErrorString);\n  }\n\n  // Handles errors in location fetching.\n  handlePositionError(error) {\n    const positionErrorString = \"Error in fetching position: \" + error.message;\n    this.setState({position: ResponseUtils.ResponseFailure(positionErrorString)});\n    // Rethrow the error for subsequent nodes.\n    throw new Error(positionErrorString);\n  }\n\n  // Fetches location and sensor readings, and updates the status.\n  updateStatus(refreshLocation) {\n    console.log(\"[\" + new Date() + \"] updating...\");\n\n    this.setState({sensorModels: ResponseUtils.ResponsePending()});\n\n    var positionPromise;\n\n    var hasPreviousPosition =\n      (this.state.position != null &&\n        this.state.position[ResponseUtils.ResponseProperties.TAG] ===\n        ResponseUtils.ResponseStates.SUCCESS);\n\n    if (!refreshLocation && hasPreviousPosition) {\n      positionPromise = Promise.resolve(\n        this.state.position[ResponseUtils.ResponseProperties.VALUE]);\n    } else {\n      this.setState({position: ResponseUtils.ResponsePending()});\n      // Issue requests for position and sensor readings.\n      positionPromise = function (options) {\n          return new Promise(function(resolve, reject) {\n            navigator.geolocation.getCurrentPosition(resolve, reject, options);\n          });\n      }()\n        .then(position =>\n          constructLocationData(\n            parseFloat(position.coords.latitude),\n            parseFloat(position.coords.longitude)))\n        .then(position => {\n          this.setState({\n            position: ResponseUtils.ResponseSuccess(position)\n          });\n          // Return the original position, so that subsequent logic can work with it.\n          return position;\n        })\n      .catch(error => this.handlePositionError(error));\n    }\n\n    var rawResultsPromise = getRawResults();\n    // Check for errors with the sensor reading per se, because Promise.all fails\n    // fast.\n    // Update eagerly if there's a failure.\n    // In the successful case, we can't update until we have both position and\n    // sensor readings.\n    rawResultsPromise = rawResultsPromise\n      .catch(error => this.handleResultError(error));\n\n    // Compute PM2.5 and update UI.\n    Promise.all([rawResultsPromise, positionPromise])\n      .then(promises => getSortedResults(promises[0], promises[1]))\n      .then(sortedResults => sortedResults.slice(0, MAX_SENSORS))\n      .then(sortedResults => constructSensorModels(sortedResults))\n      .then(sensorModels =>\n        this.setState({\n          sensorModels: ResponseUtils.ResponseSuccess(sensorModels)\n        }))\n      // Either the location or the sensor promise failed (or some business\n      // logic broke).\n      // Since sensorModels depends on both being successful, update its state.\n      .catch(error =>\n        this.setState({\n          sensorModels: ResponseUtils.ResponseFailure(error.message)\n        }));\n  }\n}\n\nexport default Status;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport {CSSTransition} from 'react-transition-group';\nimport './index.css';\nimport Button from './Button';\nimport Status from './Status';\n\nclass Monitor extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      statusActive: false,\n    };\n  }\n\n  renderButton() {\n    return(\n      <div class=\"container p-3\">\n        <Button\n          handleClick={() => this.toggleStatus()}\n        />\n      </div>);\n  }\n\n  toggleStatus() {\n    this.setState({statusActive: !this.state.statusActive});\n  }\n\n  renderStatusPlaceholder(statusActive, appearFn) {\n    // Exit animations wouldn't work, because of the immediate unrendering.\n    return(\n      <CSSTransition\n        in={statusActive}\n        appear={true}\n        timeout={300}\n        classNames=\"StatusTransition\"\n      >\n        <div>\n          {statusActive && appearFn}\n        </div>\n      </CSSTransition>\n    );\n  }\n\n  renderStatus() {\n    const pollIntervalMillis =  300000; // 5 minutes\n    return(\n      <div class=\"container p-3\">\n        <Status\n          pollIntervalMillis={pollIntervalMillis}\n        />\n      </div>);\n  }\n\n  render() {\n    return(\n      <div\n        className=\"Monitor\"\n        class=\"container m-5\"\n      >\n        {this.renderButton()}\n        {this.renderStatusPlaceholder(\n          this.state.statusActive,\n          this.renderStatus())}\n      </div>\n    );\n  }\n}\n\nReactDOM.render(\n  <Monitor />,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}